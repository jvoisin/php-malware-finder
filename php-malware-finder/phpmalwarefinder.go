package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/hillu/go-yara/v4"
	"github.com/jessevdk/go-flags"
)

const RulesURI = "https://raw.githubusercontent.com/nbs-system/php-malware-finder/master/php-malware-finder/"
const RulesFile = "php.yar"
const DefaultDir = "/etc/phpmalwarefinder"
const ScanMaxDuration = time.Duration(60)
const TooShort = "TooShort"
const TooShortMaxLines = 2
const TooShortMinChars = 300
const DangerousMatchWeight = 2
const DangerousMinScore = 3
const FileBufferSize = 32 * 1024 // 32KB
const YaraMaxThreads = 32

var args struct { // command-line arguments specs using github.com/jessevdk/go-flags
	RulesDir      string   `short:"r" long:"rules-dir" description:"Rules location (default: /etc/phpmalwarefinder or .)"`
	ShowAll       bool     `short:"a" long:"show-all" description:"Display all matched rules"`
	Fast          bool     `short:"f" long:"fast" description:"Enable YARA's fast mode"`
	RateLimit     int      `short:"R" long:"rate-limit" description:"Max. filesystem ops per second, 0 for no limit" default:"0"`
	Verbose       bool     `short:"v" long:"verbose" description:"Verbose mode"`
	Workers       int      `short:"w" long:"workers" description:"Number of workers to spawn for scanning" default:"32"`
	LongLines     bool     `short:"L" long:"long-lines" description:"Check long lines"`
	ExcludeCommon bool     `short:"c" long:"exclude-common" description:"Do not scan files with common extensions"`
	ExcludeImgs   bool     `short:"i" long:"exclude-imgs" description:"Do not scan image files"`
	ExcludedExts  []string `short:"x" long:"exclude-ext" description:"Additional file extensions to exclude"`
	Update        bool     `short:"u" long:"update" description:"Update rules"`
	Positional    struct {
		Target string
	} `positional-args:"yes"`
}
var scanFlags yara.ScanFlags
var stoppedWorkers int
var lineFeed = []byte{'\n'}
var dangerousMatches = map[string]struct{}{
	"PasswordProtection": {},
	"Websites":           {},
	"TooShort":           {},
	"NonPrintableChars":  {},
}
var excludedDirs = [...]string{
	"/.git/", "/.hg/", "/.svn/", "/.CVS/",
}
var excludedExts = map[string]struct{}{}
var commonExts = [...]string{
	".js", ".coffee", ".map", ".min", ".css", ".less", // static files
	".zip", ".rar", ".7z", ".gz", ".bz2", ".xz", ".tar", ".tgz", // archives
	".txt", ".csv", ".json", ".rst", ".md", ".yaml", ".yml", // plain text
	".so", ".dll", ".bin", ".exe", ".bundle", // binaries
}
var imageExts = [...]string{
	".png", ".jpg", ".jpeg", ".gif", ".svg", ".bmp", ".ico",
}
var scannedFilesCount int

// handleError is a generic error handler which displays the error message to the user and exits if required.
func handleError(err error, exit bool) {
	if err != nil {
		fmt.Println("ERROR:", err.Error())
		if exit {
			os.Exit(1)
		}
	}
}

// updateRules downloads latest YARA rules from phpmalwarefinder GitHub repository.
// Download location is either `args.RulesDir`, `/etc/phpmalwarefinder`, or the current directory.
func updateRules() {
	if args.Verbose {
		fmt.Println("DEBUG: updating ruleset")
	}

	downloadFile := func(uri string) []byte {
		resp, err := http.Get(uri)
		handleError(err, true)
		//defer resp.Body.Close()
		defer func() {
			err := resp.Body.Close()
			handleError(err, false)
		}()
		data, err := ioutil.ReadAll(resp.Body)
		handleError(err, true)
		return data
	}
	writeFile := func(dst string, data []byte) {
		err := ioutil.WriteFile(dst, data, 0444)
		handleError(err, true)
	}

	rulesFiles := [...]string{
		"php.yar",
		"whitelist.yar", "whitelists/drupal.yar", "whitelists/magento1ce.yar",
		"whitelists/magento2.yar", "whitelists/phpmyadmin.yar", "whitelists/prestashop.yar",
		"whitelists/symfony.yar", "whitelists/wordpress.yar"}

	// check if rules exist in args.RulesDir, /etc/phpmalwarefinder, or the current directory
	if _, err := os.Stat(args.RulesDir); os.IsNotExist(err) {
		cwd, _ := os.Getwd()
		commonPath := path.Join(cwd, RulesFile)
		if _, err := os.Stat(commonPath); os.IsNotExist(err) {
			fmt.Printf("ERROR: no rules in %s or ./, exiting\n", args.RulesDir)
			os.Exit(1)
		}
	}

	// download rules
	for _, rule := range rulesFiles {
		rulesUri := RulesURI + rule
		data := downloadFile(rulesUri)
		outPath := path.Join(args.RulesDir, rule)
		writeFile(outPath, data)
		fmt.Printf("updated %s\n", rule)
	}
}

// fileStats takes a file path as argument and returns its lines and characters count.
// File reading is done using a 32KB buffer to minimize memory usage.
func fileStats(filepath string) (int, int, error) {
	f, err := os.Open(filepath)
	handleError(err, true)
	defer func() {
		err := f.Close()
		handleError(err, false)
	}()
	charCount, lineCount := 0, 0
	buf := make([]byte, FileBufferSize)
	for {
		chunkSize, err := f.Read(buf)
		charCount += chunkSize
		lineCount += bytes.Count(buf[:chunkSize], lineFeed)
		switch {
		case err == io.EOF:
			return charCount, lineCount, nil
		case err != nil:
			return charCount, lineCount, err
		}
	}
}

// makeScanner creates a YARA scanner with the appropriate options set.
func makeScanner(rules *yara.Rules) *yara.Scanner {
	scanner, err := yara.NewScanner(rules)
	handleError(err, true)
	scanner.SetFlags(scanFlags)
	scanner.SetTimeout(ScanMaxDuration)
	return scanner
}

// processFiles reads file paths from the `targets` channel, scans it, and writes matches to the `results` channel.
// Scanning is done using YARA `rules`, and using `fileStats` if `args.LongLines` is set.
// `ticker` is a `time.Time` object created with `time.Tick` used to throttle file scans to minimize impact on I/O.
func processFiles(rules *yara.Rules, targets <-chan string, results chan<- map[string][]yara.MatchRule, ticker <-chan time.Time) {
	scanner := makeScanner(rules)
	for target := range targets {
		<-ticker
		scannedFilesCount++
		result := map[string][]yara.MatchRule{target: {}}

		if args.LongLines {
			charCount, lineCount, err := fileStats(target)
			handleError(err, false)
			if lineCount <= TooShortMaxLines && charCount >= TooShortMinChars {
				tooShort := yara.MatchRule{Rule: TooShort}
				result[target] = append(result[target], tooShort)
			}
		}

		var matches yara.MatchRules
		err := scanner.SetCallback(&matches).ScanFile(target)
		if err != nil {
			fmt.Println("ERROR:", err.Error())
			continue
		}
		for _, match := range matches {
			result[target] = append(result[target], match)
		}
		results <- result
	}
	stoppedWorkers++
	if stoppedWorkers == args.Workers {
		close(results)
	}
}

// scanDir recursively crawls `dirName`, and writes file paths to the `targets` channel.
// Files sent to `targets` are filtered according to their extensions.
func scanDir(dirName string, targets chan<- string, ticker <-chan time.Time) {
	visit := func(pathName string, fileInfo os.FileInfo, err error) error {
		<-ticker
		if !fileInfo.IsDir() {
			for _, dir := range excludedDirs {
				if strings.Contains(pathName, dir) {
					return nil
				}
			}
			fileExt := filepath.Ext(fileInfo.Name())
			if _, exists := excludedExts[fileExt]; !exists {
				targets <- pathName
			}
		}
		return nil
	}
	err := filepath.Walk(dirName, visit)
	handleError(err, false)
	close(targets)
}

func main() {
	startTime := time.Now()
	_, _ = flags.Parse(&args)

	// check config path
	if args.RulesDir == "" {
		args.RulesDir = DefaultDir
		if _, err := os.Stat(args.RulesDir); os.IsNotExist(err) {
			args.RulesDir, _ = os.Getwd()
		}
	}
	if args.Verbose {
		fmt.Printf("DEBUG: rules directory: '%s'\n", args.RulesDir)
	}

	// update rules if required
	if args.Update {
		updateRules()
		os.Exit(0)
	}

	// add custom excluded file extensions
	if args.ExcludeCommon {
		for _, commonExt := range commonExts {
			excludedExts[commonExt] = struct{}{}
		}
	}
	if args.ExcludeImgs || args.ExcludeCommon {
		for _, imgExt := range imageExts {
			excludedExts[imgExt] = struct{}{}
		}
	}
	for _, ext := range args.ExcludedExts {
		if string(ext[0]) != "." {
			ext = "." + ext
		}
		excludedExts[ext] = struct{}{}
	}
	if args.Verbose {
		extList := make([]string, len(excludedExts))
		i := 0
		for ext := range excludedExts {
			extList[i] = ext[1:]
			i++
		}
		fmt.Printf("DEBUG: excluded file extensions: %s\n", strings.Join(extList, ","))
	}

	// load appropriate YARA rules
	rulePath := path.Join(args.RulesDir, RulesFile)
	if _, err := os.Stat(rulePath); os.IsNotExist(err) {
		fmt.Printf("ERROR: %s not found in default locations or in %s\n", RulesFile, args.RulesDir)
		os.Exit(1)
	}
	data, _ := ioutil.ReadFile(rulePath)
	rules, _ := yara.Compile(string(data), nil)
	if args.Verbose {
		fmt.Printf("DEBUG: ruleset loaded: '%s'\n", rulePath)
	}

	// set YARA scan flags
	if args.Fast {
		scanFlags = yara.ScanFlags(yara.ScanFlagsFastMode)
	} else {
		scanFlags = yara.ScanFlags(0)
	}

	// check if requested threads count is not greater than YARA's MAX_THREADS
	if args.Workers > YaraMaxThreads {
		fmt.Printf("WARNING: workers count too high, using %d instead of %d\n", YaraMaxThreads, args.Workers)
		args.Workers = YaraMaxThreads
	}

	// scan target
	if f, err := os.Stat(args.Positional.Target); os.IsNotExist(err) {
		fmt.Println("ERROR: invalid target")
		os.Exit(1)
	} else {
		if args.Verbose {
			fmt.Printf("DEBUG: scan workers: %d\n", args.Workers)
			fmt.Printf("DEBUG: target: '%s'\n", args.Positional.Target)
		}
		if f.IsDir() { // parallelized folder scan
			// create communication channels
			targets := make(chan string)
			results := make(chan map[string][]yara.MatchRule)

			// rate limit
			var tickerRate time.Duration
			if args.RateLimit == 0 {
				tickerRate = time.Nanosecond
			} else {
				tickerRate = time.Second / time.Duration(args.RateLimit)
			}
			ticker := time.Tick(tickerRate)
			if args.Verbose {
				fmt.Println("DEBUG: delay between fs ops:", tickerRate.String())
			}

			// start consumers and producer workers
			for w := 1; w <= args.Workers; w++ {
				go processFiles(rules, targets, results, ticker)
			}
			go scanDir(args.Positional.Target, targets, ticker)

			// read results
			matchCount := make(map[string]int)
			var keepListing bool
			var countedDangerousMatch bool
			for result := range results {
				for target, matchedSigs := range result {
					keepListing = true
					matchCount[target] = 0
					countedDangerousMatch = false
					for _, sig := range matchedSigs {
						matchCount[target] += DangerousMatchWeight
						if !countedDangerousMatch {
							if _, exists := dangerousMatches[sig.Rule]; exists {
								matchCount[target]++
							}
							countedDangerousMatch = true
						}
						if keepListing {
							fmt.Printf("%s %s\n", target, sig.Rule)
							if !args.ShowAll {
								keepListing = false
							}
						}
					}
				}
			}
			fmt.Println("\n===================================================")
			fmt.Println(" You should take a look at the files listed below:")
			fmt.Println("===================================================")
			fmt.Println("")
			for target, count := range matchCount {
				if count >= DangerousMinScore {
					fmt.Println(target)
				}
			}
		} else { // single file mode
			scannedFilesCount++
			var matches yara.MatchRules
			scanner := makeScanner(rules)
			err := scanner.SetCallback(&matches).ScanFile(args.Positional.Target)
			handleError(err, true)
			for _, match := range matches {
				fmt.Printf("%s %s\n", args.Positional.Target, match.Rule)
				if args.Verbose {
					for _, matchString := range match.Strings {
						fmt.Printf("DEBUG: 0x%x:%s: %s\n", matchString.Offset, matchString.Name, matchString.Data)
					}
				}
				if !args.ShowAll {
					break
				}
			}
		}
		if args.Verbose {
			endTime := time.Now()
			fmt.Printf("DEBUG: scanned %d files in %s\n", scannedFilesCount, endTime.Sub(startTime).String())
		}
	}
}
